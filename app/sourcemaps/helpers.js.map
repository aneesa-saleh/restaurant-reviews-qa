{"version":3,"sources":["swhelper.js","dbhelper.js","mischelpers.js","toasts.js","lazyLoad.js"],"names":["registerServiceWorker","navigator","serviceWorker","register","catch","error","console","log","cleanMapboxTilesCache","caches","open","then","cache","keys","requests","length","slice","forEach","request","delete","openDatabase","requestFromServiceWorker","idb","upgradeDb","oldVersion","createObjectStore","keyPath","createIndex","transaction","objectStore","Promise","resolve","dbPromise","DBHelper","db","restaurantsURL","concat","DATABASE_URL","fetch","response","ok","json","status","reject","store","getAll","idbRestaurants","fetchResponse","clone","fetchedRestaurants","restaurant","put","id","callback","restaurantByIdURL","get","Number","parseInt","idbRestaurant","fetchedRestaurant","restaurantId","reviewsByRestaurantIdURL","index","idbReviews","fetchedReviews","review","reviews","cuisine","fetchRestaurants","restaurants","results","filter","r","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","options","size","singleValue","photograph_small_2x","photograph_small_1x","photograph_medium_2x","photograph_medium_1x","wide","photograph_large_wide","photograph_large","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","setFavouriteStatusUrl","method","updatedRestaurant","rating","comments","addReviewUrl","body","JSON","stringify","restaurant_id","newReview","formatDate","date","day","getDate","month","getMonth","year","getFullYear","stringToBoolean","string","toastTimer","pendingToasts","shouldRestartToastTimer","pauseToastTimer","clearTimeout","restartToastTimer","setTimeout","hideToast","enqueueToast","message","type","unshift","showToast","toast","document","getElementById","toastText","classList","remove","setAttribute","pop","toastElement","toastIcon","innerHTML","className","loadElement","handleIntersection","entries","observer","entry","isIntersecting","element","target","unobserve","requestAnimationFrame","registerObserver","elementsToObserve","loadElementCallback","IntersectionObserver","observe","fetchImage","image","Image","src","onload","onerror"],"mappings":"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","file":"../helpers/helpers.js","sourcesContent":["const registerServiceWorker = () => {\n  if (!navigator.serviceWorker) return;\n\n  navigator.serviceWorker.register('/service-worker.js')\n    .catch(error => console.log(error));\n};\n\nconst cleanMapboxTilesCache = () => {\n  caches.open('restaurant-reviews-map-tiles').then(\n    cache => cache.keys().then((requests) => {\n      const { length } = requests;\n      if (length <= 12) return;\n\n      // keep only the 12 most recent tiles\n      requests.slice(0, length - 12).forEach((request) => {\n        cache.delete(request);\n      });\n    }),\n  );\n};\n\n/* eslint-disable default-case */\n/* eslint-disable no-fallthrough */\n\nconst openDatabase = (requestFromServiceWorker) => {\n  if (!navigator.serviceWorker && !requestFromServiceWorker) return Promise.resolve();\n\n  return idb.open('restaurant-reviews', 4, (upgradeDb) => {\n    switch (upgradeDb.oldVersion) {\n      case 0: {\n        upgradeDb.createObjectStore('restaurants', {\n          keyPath: 'id',\n        });\n      }\n      case 1: { const reviewsStore = upgradeDb.createObjectStore('reviews', {\n        keyPath: 'id',\n      });\n      reviewsStore.createIndex('restaurant_id', 'restaurant_id');\n      }\n      case 2: {\n        upgradeDb.createObjectStore('outbox', {\n          keyPath: 'request_id',\n        });\n      }\n      case 3: {\n        const outboxStore = upgradeDb.transaction.objectStore('outbox');\n        outboxStore.createIndex('restaurant_id', 'restaurant_id');\n      }\n    }\n  });\n};\n","const dbPromise = openDatabase();\n\n/**\n * Common database helper functions.\n */\nclass DBHelper {\n  /**\n   * Database URL.\n   * Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    return 'https://api-restaurant-reviews.glitch.me';\n  }\n\n  /**\n   * Fetch all restaurants.\n   */\n  static fetchRestaurants() {\n    return dbPromise.then((db) => {\n      const restaurantsURL = `${DBHelper.DATABASE_URL}/restaurants`;\n\n      if (!db) {\n        // make regular fetch call\n        return fetch(restaurantsURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            return response.json();\n          });\n      }\n\n      // return restaurants from IDB\n      let store = db.transaction('restaurants').objectStore('restaurants');\n      return store.getAll().then((idbRestaurants) => {\n        const fetchResponse = fetch(restaurantsURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            const responseJSON = response.clone().json();\n            // update IDB restaurants with fetch response even if values from IDB will be returned\n            responseJSON.then((fetchedRestaurants) => {\n              store = db.transaction('restaurants', 'readwrite').objectStore('restaurants');\n              fetchedRestaurants.forEach((restaurant) => {\n                store.put(restaurant);\n              });\n            });\n            return response.json();\n          });\n        if (idbRestaurants && idbRestaurants.length > 0) {\n          return idbRestaurants;\n        }\n        // if IDB.restaurants is empty, return the fetch response instead\n        return fetchResponse;\n      });\n    });\n  }\n\n  /**\n   * Fetch a restaurant by its ID.\n   */\n  static fetchRestaurantById(id, callback) {\n    dbPromise.then((db) => {\n      const restaurantByIdURL = `${DBHelper.DATABASE_URL}/restaurants/${id}`;\n\n      if (!db) {\n        // make regular fetch call\n        return fetch(restaurantByIdURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            return response.json();\n          });\n      }\n\n      // return restaurant from IDB\n      let store = db.transaction('restaurants').objectStore('restaurants');\n      // id comes as a string from the url, convert to a number before lookup\n      return store.get(Number.parseInt(id, 10)).then((idbRestaurant) => {\n        const fetchResponse = fetch(restaurantByIdURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            const responseJSON = response.clone().json();\n            // update IDB restaurants with fetch response even if value from IDB will be returned\n            responseJSON.then((fetchedRestaurant) => {\n              store = db.transaction('restaurants', 'readwrite').objectStore('restaurants');\n              store.put(fetchedRestaurant);\n            });\n            return response.json();\n          });\n        return idbRestaurant || fetchResponse;\n      });\n    }).then((restaurant) => { callback(null, restaurant); })\n      .catch((error) => { callback(error, null); });\n  }\n\n\n  /**\n   * Fetch reviews by restaurant ID.\n   */\n  static fetchReviewsByRestaurantId(restaurantId, callback) {\n    dbPromise.then((db) => {\n      const reviewsByRestaurantIdURL = `${DBHelper.DATABASE_URL}/reviews/?restaurant_id=${restaurantId}`;\n\n      if (!db) {\n        // make regular fetch call\n        return fetch(reviewsByRestaurantIdURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            return response.json();\n          });\n      }\n\n      // return reviews from IDB\n      let store = db.transaction('reviews').objectStore('reviews');\n      const reviewsByRestaurantIdIndex = store.index('restaurant_id');\n      // id comes as a string from the url, convert to a number before lookup\n      return reviewsByRestaurantIdIndex.getAll(Number.parseInt(restaurantId, 10)).then((idbReviews) => {\n        const fetchResponse = fetch(reviewsByRestaurantIdURL)\n          .then((response) => {\n            if (!response.ok) {\n              const error = (`Request failed. Returned status of ${response.status}`);\n              return Promise.reject(error);\n            }\n            const responseJSON = response.clone().json();\n            // update IDB reviews with fetch response even if values from IDB will be returned\n            responseJSON.then((fetchedReviews) => {\n              store = db.transaction('reviews', 'readwrite').objectStore('reviews');\n              fetchedReviews.forEach((review) => {\n                store.put(review);\n              });\n            });\n            return response.json();\n          });\n        if (idbReviews && idbReviews.length > 0) {\n          return idbReviews;\n        }\n        // if IDB.reviews is empty, return the fetch response instead\n        return fetchResponse;\n      });\n    }).then((reviews) => { callback(null, reviews); })\n      .catch((error) => { callback(error, null); });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants().then((restaurants) => {\n      // Filter restaurants to have only given cuisine type\n      const results = restaurants.filter(r => r.cuisine_type == cuisine);\n      callback(null, results);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Fetch restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants().then((restaurants) => {\n      // Filter restaurants to have only given neighborhood\n      const results = restaurants.filter(r => r.neighborhood == neighborhood);\n      callback(null, results);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants().then((restaurants) => {\n      let results = restaurants;\n      if (cuisine != 'all') { // filter by cuisine\n        results = results.filter(r => r.cuisine_type == cuisine);\n      }\n      if (neighborhood != 'all') { // filter by neighborhood\n        results = results.filter(r => r.neighborhood == neighborhood);\n      }\n      callback(null, results);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Fetch all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants().then((restaurants) => {\n      // Get all neighborhoods from all restaurants\n      const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);\n      // Remove duplicates from neighborhoods\n      const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i);\n      callback(null, uniqueNeighborhoods);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Fetch all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants().then((restaurants) => {\n      // Get all cuisines from all restaurants\n      const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n      // Remove duplicates from cuisines\n      const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i);\n      callback(null, uniqueCuisines);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return (`./restaurant.html?id=${restaurant.id}`);\n  }\n\n  /**\n   * Restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant, options) {\n    if (options) {\n      if (options.size === 'small') {\n        if (options.singleValue === true) return `img/${restaurant.photograph_small_2x}`;\n        return `img/${restaurant.photograph_small_1x} 1x, img/${restaurant.photograph_small_2x} 2x`;\n      } if (options.size === 'medium') {\n        if (options.singleValue === true) return `img/${restaurant.photograph_medium_2x}`;\n        return `img/${restaurant.photograph_medium_1x} 1x, img/${restaurant.photograph_medium_2x} 2x`;\n      } if (options.size === 'large' && options.wide) {\n        return `img/${restaurant.photograph_large_wide}`;\n      }\n    }\n    return (`img/${restaurant.photograph_large}`);\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    // https://leafletjs.com/reference-1.3.0.html#marker\n    const marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\n      {\n        title: restaurant.name,\n        alt: restaurant.name,\n        url: DBHelper.urlForRestaurant(restaurant),\n      });\n    marker.addTo(newMap);\n    return marker;\n  }\n\n  /**\n   * Mark or unmark a restaurant as favourite\n   */\n  static setRestaurantFavouriteStatus(restaurantId, status, callback) {\n    const setFavouriteStatusUrl = `${DBHelper.DATABASE_URL}/restaurants/${restaurantId}/?is_favorite=${status}`;\n    fetch(setFavouriteStatusUrl, { method: 'PUT' }).then((response) => {\n      if (!response.ok) {\n        return Promise.reject();\n      }\n      return response.json();\n    }).then((updatedRestaurant) => {\n      dbPromise.then((db) => {\n        const store = db.transaction('restaurants', 'readwrite').objectStore('restaurants');\n        store.put(updatedRestaurant);\n      });\n      callback(null, updatedRestaurant);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Add a review for a restaurant\n   */\n  static addReview(restaurantId, name, rating, comments, callback) {\n    const addReviewUrl = `${DBHelper.DATABASE_URL}/reviews`;\n    const body = JSON.stringify({\n      restaurant_id: restaurantId,\n      name,\n      rating,\n      comments,\n    });\n    fetch(addReviewUrl, { method: 'POST', body }).then((response) => {\n      if (!response.ok) {\n        const error = (`Request failed. Returned status of ${response.status}`);\n        return Promise.reject(error);\n      }\n      return response.json();\n    }).then((newReview) => {\n      callback(null, newReview);\n    }).catch((error) => {\n      callback(error, null);\n    });\n  }\n\n  /**\n   * Get reviews that have been saved offline\n   */\n  static getOutboxReviews(restaurantId, callback) {\n    dbPromise.then((db) => {\n      if (!db) {\n        const error = 'Error connecting to IndexedDB';\n        callback(error, null);\n        return;\n      }\n      const store = db.transaction('outbox').objectStore('outbox');\n      const reviewsByRestaurantIdIndex = store.index('restaurant_id');\n      // id comes as a string from the url, convert to a number before lookup\n      reviewsByRestaurantIdIndex.getAll(Number.parseInt(restaurantId, 10)).then((idbReviews) => {\n        callback(null, idbReviews);\n      });\n    });\n  }\n}\n","// https://stackoverflow.com/questions/3552461/how-to-format-a-javascript-date\nfunction formatDate(date) {\n  const monthNames = [\n    'January', 'February', 'March',\n    'April', 'May', 'June', 'July',\n    'August', 'September', 'October',\n    'November', 'December',\n  ];\n\n  const day = date.getDate();\n  const month = monthNames[date.getMonth()];\n  const year = date.getFullYear();\n\n  return `${month} ${day}, ${year}`;\n}\n\nfunction stringToBoolean(string) {\n  if (typeof string === 'boolean') return string;\n\n  return string === 'true';\n}\n","let toastTimer = null;\nconst pendingToasts = [];\nlet shouldRestartToastTimer = false;\n\nfunction pauseToastTimer() {\n  clearTimeout(toastTimer);\n  toastTimer = null;\n  shouldRestartToastTimer = true;\n}\n\nfunction restartToastTimer() {\n  if (shouldRestartToastTimer) { // this check is necessary in case toast was closed\n    shouldRestartToastTimer = false;\n    toastTimer = setTimeout(hideToast, 2000);\n  }\n}\n\nfunction enqueueToast(message, type) {\n  // add the toast to the beginning of the array (queue)\n  pendingToasts.unshift({ message, type });\n  if (toastTimer === null) { // no toast is currently showing\n    showToast();\n  }\n}\n\nfunction hideToast() {\n  clearTimeout(toastTimer);\n  toastTimer = null;\n  shouldRestartToastTimer = false;\n  const toast = document.getElementById('toast');\n  const toastText = document.getElementById('toast-text');\n  toast.classList.remove('show');\n  setTimeout(() => {\n    toastText.setAttribute('aria-live', 'polite');\n    // show the next toast if there is any pending\n    showToast();\n  }, 0);\n}\n\nfunction showToast() {\n  const toast = pendingToasts.pop();\n  if (!toast || !toast.message) return;\n\n  const { message, type } = toast;\n  const toastElement = document.getElementById('toast');\n  const toastText = document.getElementById('toast-text');\n  const toastIcon = document.getElementById('toast-icon');\n\n  toastText.setAttribute('aria-live', 'polite');\n  toastText.innerHTML = message;\n\n  if (type === 'error') {\n    toastElement.className = 'toast show error';\n    toastIcon.className = 'fas fa-exclamation-triangle';\n  } else if (type === 'success') {\n    toastElement.className = 'toast show success';\n    toastIcon.className = 'fas fa-check';\n  } else {\n    toastElement.className = 'toast show';\n    toastIcon.className = 'fas fa-info-circle';\n  }\n\n  clearTimeout(toastTimer);\n  setTimeout(() => {\n    toastText.setAttribute('aria-live', 'off');\n  }, 0);\n  toastTimer = setTimeout(hideToast, 8000);\n}\n","let loadElement = () => {};\n\n/**\n * Function to call when an element comes into focus\n */\nfunction handleIntersection(entries, observer) {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      const element = entry.target;\n      observer.unobserve(element);\n      requestAnimationFrame(() => {\n        loadElement(element);\n      });\n    }\n  });\n}\n\nfunction registerObserver(elementsToObserve, loadElementCallback) {\n  loadElement = loadElementCallback;\n  const observer = new IntersectionObserver(handleIntersection);\n  elementsToObserve.forEach((element) => {\n    observer.observe(element);\n  });\n}\n\nfunction fetchImage(url) {\n  return new Promise((resolve, reject) => {\n    const image = new Image();\n    image.src = url;\n    image.onload = resolve;\n    image.onerror = reject;\n  });\n}\n"]}